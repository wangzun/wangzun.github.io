<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on wangzun&#39;s blog</title>
    <link>http://wangzun.github.io/posts/</link>
    <description>Recent content in Posts on wangzun&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 21 Jul 2016 16:05:06 +0900</lastBuildDate>
    <atom:link href="http://wangzun.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>erlang有用的小细节</title>
      <link>http://wangzun.github.io/posts/erlang/</link>
      <pubDate>Thu, 21 Jul 2016 16:05:06 +0900</pubDate>
      
      <guid>http://wangzun.github.io/posts/erlang/</guid>
      <description>

&lt;h5 id=&#34;1-erlang-shell用法:9f3b6997f78b7d4fd24f17461ec402ee&#34;&gt;1. erlang shell用法&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;rp(Term)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Prints a term using the record definitions known to the shell. All of Term is printed; the depth is not limited as is the case when a return value is printed.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;b()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Prints the current variable bindings.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;f() , f(X)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Removes variable bindings.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;v(N)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Uses the return value of command N in the current command
2&amp;gt; fun() -&amp;gt; ok end.
#Fun&amp;lt;erl_eval.20.54118792&amp;gt;
3&amp;gt;
3&amp;gt; Fun = v(-1).
#Fun&amp;lt;erl_eval.20.54118792&amp;gt;
4&amp;gt; Fun.
#Fun&amp;lt;erl_eval.20.54118792&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2&amp;gt; Pid = self().
3&amp;gt; erlang:spawn(fun() -&amp;gt; Pid ! test end).
&amp;lt;0.38.0&amp;gt;
4&amp;gt; flush().
Shell got test
ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;catch_exception(true)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;没有catch_exception(true)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1&amp;gt; Table = ets:new(test1,[]).
16400
2&amp;gt; ets:info(Table).
[{read_concurrency,false},
 {write_concurrency,false},
 {compressed,false},
 {memory,305},
 {owner,&amp;lt;0.33.0&amp;gt;},
 {heir,none},
 {name,test1},
 {size,0},
 {node,nonode@nohost},
 {named_table,false},
 {type,set},
 {keypos,1},
 {protection,protected}]
3&amp;gt;
3&amp;gt; 1/0.
** exception error: an error occurred when evaluating an arithmetic expression
     in operator  &#39;/&#39;/2
        called as 1 / 0
4&amp;gt;
4&amp;gt; ets:info(Table).
undefined
5&amp;gt; self().
&amp;lt;0.37.0&amp;gt;
6&amp;gt; 1/0.
** exception error: an error occurred when evaluating an arithmetic expression
     in operator  &#39;/&#39;/2
        called as 1 / 0
7&amp;gt; self().
&amp;lt;0.41.0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用catch_exception(true)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;8&amp;gt; catch_exception(true).
false
9&amp;gt;
9&amp;gt; self().
&amp;lt;0.41.0&amp;gt;
10&amp;gt;
10&amp;gt; 1/0.
* exception error: an error occurred when evaluating an arithmetic expression
    in operator  &#39;/&#39;/2
       called as 1 / 0
11&amp;gt; self().
&amp;lt;0.41.0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;2-erlang-node:9f3b6997f78b7d4fd24f17461ec402ee&#34;&gt;2.erlang node&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;启动分布式节点&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;erl -name test1@0.0.0.0

net_kernel:start([&#39;test1@0.0.0.0&#39;]).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-hidden&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hidden connections are not published on either of the connected nodes
a,b节点为普通节点，c为hidden节点，当a与c连接，b与c连接后，a与b不会连接
net_kernel:connect_node(Node)
nodes()
ets:tab2list(sys_dist)
epmd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;rpc&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-kernel dist_auto_connect never

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;group_leader&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Every process is a member of some process group and all groups have a group leader. All I/O from the group is channeled to the group leader. When a new process is spawned, it gets the same group leader as the spawning process.
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;3-ets:9f3b6997f78b7d4fd24f17461ec402ee&#34;&gt;3.ets&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;ets:all()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Returns a list of all tables at the node.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ets:info()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ets:new(Name,Op)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ets:first(Tab)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ets:last(Tab)
ets:next(Tab,Key)
ets:prev(Tab,Key)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ets:select(Tab,MatchSpec)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ets:fun2ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;4-热更新:9f3b6997f78b7d4fd24f17461ec402ee&#34;&gt;4.热更新&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;c:l(Mod)&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;5-system-limit:9f3b6997f78b7d4fd24f17461ec402ee&#34;&gt;5.system_limit&lt;/h5&gt;

&lt;h5 id=&#34;6-开源库:9f3b6997f78b7d4fd24f17461ec402ee&#34;&gt;6.开源库&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;recon&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>其他文章</title>
      <link>http://wangzun.github.io/posts/hugo-create-blog/</link>
      <pubDate>Thu, 26 May 2016 16:05:06 +0800</pubDate>
      
      <guid>http://wangzun.github.io/posts/hugo-create-blog/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.jianshu.com/users/f3f29a3ca903/latest_articles&#34;&gt;其他文章&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mongodb学习笔记</title>
      <link>http://wangzun.github.io/posts/mongodb-notes/</link>
      <pubDate>Thu, 26 May 2016 16:05:06 +0900</pubDate>
      
      <guid>http://wangzun.github.io/posts/mongodb-notes/</guid>
      <description>

&lt;h5 id=&#34;分片-副本级集群对比:afb814d1e0b452328a71bc59001afa4a&#34;&gt;分片，副本级集群对比&lt;/h5&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;分片&lt;/th&gt;
&lt;th&gt;副本级集群&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;实现意义&lt;/td&gt;
&lt;td&gt;&lt;code&gt;提升并发性能&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;数据沉余，提升度性能&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;架构上&lt;/td&gt;
&lt;td&gt;&lt;code&gt;水平化&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;中心化&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;实现原理&lt;/td&gt;
&lt;td&gt;&lt;code&gt;数据分散&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;数据镜像&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;维护成本&lt;/td&gt;
&lt;td&gt;&lt;code&gt;相对高&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;较容易&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&#34;分片节点:afb814d1e0b452328a71bc59001afa4a&#34;&gt;分片节点&lt;/h5&gt;

&lt;p&gt;Shard节点:
&lt;code&gt;存取数据的节点( 单个mongod)&lt;/code&gt;
Config server:
&lt;code&gt;储存元数据，为mongos服务，路由到Shard&lt;/code&gt;
Mongos
&lt;code&gt;接收请求，进行消息路由&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;成员节点启动参数:afb814d1e0b452328a71bc59001afa4a&#34;&gt;成员节点启动参数&lt;/h5&gt;

&lt;p&gt;Shard:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongod --shardsvr
mongod --shardsvr --rpelSet (副本集)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Config server:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongod --configsvr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mongos&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongos --configdb &amp;lt;configdb server&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分片步骤&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; use admin
&amp;gt; sh.addShard(&amp;quot;ip:port&amp;quot;)
&amp;gt; db.runCommand({enablesharding:&amp;quot;db&amp;quot;})
&amp;gt; db.runCommand({&amp;quot;shardcollection&amp;quot;:&amp;quot;db.collection&amp;quot;,key:{&amp;quot;key&amp;quot;:1}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看shard成员&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; use config
&amp;gt; db.shards.find()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看shard状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; db.printShardingStatus()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;哈希分片&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;db.runCommand({&amp;quot;shardcollection&amp;quot;:&amp;quot;db.collection&amp;quot;,&amp;quot;key&amp;quot;:{key:hashed}})
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;范围分片和哈希分片的对比:afb814d1e0b452328a71bc59001afa4a&#34;&gt;范围分片和哈希分片的对比&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;基于范围的分片方式提供了更高效的范围查询,给定一个片键的范围,分发路由可以很简单地确定哪个数据块存储了请求需要的数据,并将请求转发到相应的分片中.&lt;/p&gt;

&lt;p&gt;不过,基于范围的分片会导致数据在不同分片上的不均衡,有时候,带来的消极作用会大于查询性能的积极作用.比如,如果片键所在的字段是线性增长的,一定时间内的所有请求都会落到某个固定的数据块中,最终导致分布在同一个分片中.在这种情况下,一小部分分片承载了集群大部分的数据,系统并不能很好地进行扩展.&lt;/p&gt;

&lt;p&gt;与此相比,基于哈希的分片方式以范围查询性能的损失为代价,保证了集群中数据的均衡.哈希值的随机性使数据随机分布在每个数据块中,因此也随机分布在不同分片中.但是也正由于随机性,一个范围查询很难确定应该请求哪些分片,通常为了返回需要的结果,需要请求所有分片.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>