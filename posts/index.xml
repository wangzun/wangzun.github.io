<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on wangzun&#39;s blog</title>
    <link>http://wangzun.github.io/posts/</link>
    <description>Recent content in Posts on wangzun&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 17 Dec 2016 14:01:01 +0800</lastBuildDate>
    <atom:link href="http://wangzun.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>erlang with soft real-time system</title>
      <link>http://wangzun.github.io/posts/preemptive/</link>
      <pubDate>Sat, 17 Dec 2016 14:01:01 +0800</pubDate>
      
      <guid>http://wangzun.github.io/posts/preemptive/</guid>
      <description>&lt;p&gt;as most erlang progamers know ,erlang is suitable for Distributed, reliable, soft real-time concurrent systems.many companies use erlang to solving their problem, like Whatsapp, RabbitMQ which need a large messge server. other feature is easy to understand but what was the soft real-time system?&lt;/p&gt;

&lt;p&gt;the soft real-time system is one of the real-time systems which need server response on time, of course, there has hard real-time system, just like the high frequency trading system, avionics , etc. they have a common character that has an absolute deadline. a soft real-time system was not so absolutely but can miss few deadlines. like sound, video，game, etc. why erlang can suitable a soft real-time system?&lt;/p&gt;

&lt;p&gt;erlang runtime system was just like a small operating system on computer,  it would create a number of schedulers when the system core numbers are, and scheduler runs two types of jobs: process and ports, every process or port share same time slice, when the time slice exhausted, it would be force tasked off execution, and another waited process or port be scheduled. erlang use preemptive multitasking and every process have 2000 reductions, not each erlang function call cost reduction but also BIF, gc, ETS, send function would cost reduction, 2000 reductions cost 0.1 ms, that was why erlang can build a soft real-time system. for example, there are 50 tasks, No.1 task cost 100ms, others cost 0.1ms. when the erlang scheduler executing the No.1 task for 0.1ms, then the No.1 task will be take off, and another task will executing. the long cost one can&amp;rsquo;t stop the others, if the system requires 100ms response, the 49 tasks up to grade, just one can&amp;rsquo;t. the system can be called soft real-time system.&lt;/p&gt;

&lt;p&gt;if you want build soft real-time system, you can use erlang.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>思考这个blog的意义</title>
      <link>http://wangzun.github.io/posts/restart/</link>
      <pubDate>Mon, 12 Dec 2016 14:05:06 +0800</pubDate>
      
      <guid>http://wangzun.github.io/posts/restart/</guid>
      <description>&lt;p&gt;对于一个表达欲望弱的人，一年可以写多少blog? 对我来说是一年5篇。仔细想想和没有写差不多，当初弄这个的原因其一是想试试hugo这服务，其二就很多人都认为写blog有好处。比较明显的几点好处在于：可以提高写作水准，可以增强知识点的记忆（对于技术blog而言），还在于可以让外界可以知晓你的知识积累。当然能有这些个好处还在于你确实在认真的写blog，而不是一年才几篇可有可无的文章。&lt;/p&gt;

&lt;p&gt;既然有实实在在的好处，问什么还是没法认真写。主要是这些好处短时间没法兑现，一个短期无法完成的目标总是会让你动力不足，当然可能也有对写blog有极高兴趣的人，这种也是存在的，哪些每天写一篇的可能就是这种人吧。不过动力不足的问题可能会可能会告一段落了，现实情况让我有写作的目的了。是这样的，由于对于现工作不满意开始观望其他工作，连续有几次面试，出了一些表达能力上面的问题，我自认还是比较热衷于技术，经常看技术书籍和其他人写的blog，但是在面试的时候总是一问一答模式，有时候自己主动说的时候也会断断续续，这到不是紧张的原因，而是确实知识面很散，自以为知道了，其实没有系统的整理，再多的&lt;strong&gt;Information&lt;/strong&gt;也不是&lt;strong&gt;knowledge&lt;/strong&gt;，这就是目前的症结，会导致面试官很片面的了解你。我自己反思了很久，觉得必须改变了。&lt;/p&gt;

&lt;p&gt;回想起来，现在记忆最深刻的还是在公司技术组做分享的时候弄得那个和算法相关的主题，直到现在我都影响深刻，要知道距离现在已经有两年了，现在回想起两年前看过什么？有操作系统，有分布式的论文，有一些数据库的代码，但是具体内容已经一片模糊了，也许只有真正用到的时候才会在绞尽脑汁的时候想起。我看到过一句话，教是最好的学习，可以让你理解的更深刻，记忆更持久。确实有实例可以证明这点。最近在用一个叫 &lt;a href=&#34;https://zh.wikipedia.org/zh-hans/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95&#34;&gt;番茄工作法&lt;/a&gt; 的东西，这个东西的主要目的是提高注意力，增强效率，我用这个方法也是如此。我发现，设定一个明确的目标，一个可控的时间是极其有效，特别是如果可以将大目标分得很细的小目标的时候，完成一个小目标就像经验条涨了，一个大目标就像升级了一样。所以我决定多参与公司的技术分享，用可以教学的目标来学习新的知识，并系统的记录在blog里面，将目标分细，当最后记录在blog里的时候就算完成一个大目标。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;有一定成就的人物，无不是以任务为中心去做事。如果我们要干一件事，我们就要把这件事干成。如果我们要学一个技能，我们就要把这个技能学会。哪怕我们只不过读一本书，我们也要把这本书读完。&amp;rdquo;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>erlang有用的小细节</title>
      <link>http://wangzun.github.io/posts/erlang/</link>
      <pubDate>Thu, 21 Jul 2016 16:05:06 +0900</pubDate>
      
      <guid>http://wangzun.github.io/posts/erlang/</guid>
      <description>

&lt;h5 id=&#34;1-erlang-shell用法:9f3b6997f78b7d4fd24f17461ec402ee&#34;&gt;1. erlang shell用法&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;rp(Term)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Prints a term using the record definitions known to the shell. All of Term is printed; the depth is not limited as is the case when a return value is printed.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;b()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Prints the current variable bindings.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;f() , f(X)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Removes variable bindings.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;v(N)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Uses the return value of command N in the current command
2&amp;gt; fun() -&amp;gt; ok end.
#Fun&amp;lt;erl_eval.20.54118792&amp;gt;
3&amp;gt;
3&amp;gt; Fun = v(-1).
#Fun&amp;lt;erl_eval.20.54118792&amp;gt;
4&amp;gt; Fun.
#Fun&amp;lt;erl_eval.20.54118792&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2&amp;gt; Pid = self().
3&amp;gt; erlang:spawn(fun() -&amp;gt; Pid ! test end).
&amp;lt;0.38.0&amp;gt;
4&amp;gt; flush().
Shell got test
ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;catch_exception(true)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;没有catch_exception(true)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1&amp;gt; Table = ets:new(test1,[]).
16400
2&amp;gt; ets:info(Table).
[{read_concurrency,false},
 {write_concurrency,false},
 {compressed,false},
 {memory,305},
 {owner,&amp;lt;0.33.0&amp;gt;},
 {heir,none},
 {name,test1},
 {size,0},
 {node,nonode@nohost},
 {named_table,false},
 {type,set},
 {keypos,1},
 {protection,protected}]
3&amp;gt;
3&amp;gt; 1/0.
** exception error: an error occurred when evaluating an arithmetic expression
     in operator  &#39;/&#39;/2
        called as 1 / 0
4&amp;gt;
4&amp;gt; ets:info(Table).
undefined
5&amp;gt; self().
&amp;lt;0.37.0&amp;gt;
6&amp;gt; 1/0.
** exception error: an error occurred when evaluating an arithmetic expression
     in operator  &#39;/&#39;/2
        called as 1 / 0
7&amp;gt; self().
&amp;lt;0.41.0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用catch_exception(true)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;8&amp;gt; catch_exception(true).
false
9&amp;gt;
9&amp;gt; self().
&amp;lt;0.41.0&amp;gt;
10&amp;gt;
10&amp;gt; 1/0.
* exception error: an error occurred when evaluating an arithmetic expression
    in operator  &#39;/&#39;/2
       called as 1 / 0
11&amp;gt; self().
&amp;lt;0.41.0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;2-erlang-node:9f3b6997f78b7d4fd24f17461ec402ee&#34;&gt;2.erlang node&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;启动分布式节点&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;erl -name test1@0.0.0.0

net_kernel:start([&#39;test1@0.0.0.0&#39;]).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-hidden&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hidden connections are not published on either of the connected nodes
a,b节点为普通节点，c为hidden节点，当a与c连接，b与c连接后，a与b不会连接
net_kernel:connect_node(Node)
nodes()
ets:tab2list(sys_dist)
epmd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;rpc&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-kernel dist_auto_connect never

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;group_leader&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Every process is a member of some process group and all groups have a group leader. All I/O from the group is channeled to the group leader. When a new process is spawned, it gets the same group leader as the spawning process.
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;3-ets:9f3b6997f78b7d4fd24f17461ec402ee&#34;&gt;3.ets&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;ets:all()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Returns a list of all tables at the node.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ets:info()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ets:new(Name,Op)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ets:first(Tab)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ets:last(Tab)
ets:next(Tab,Key)
ets:prev(Tab,Key)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ets:select(Tab,MatchSpec)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ets:fun2ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;4-热更新:9f3b6997f78b7d4fd24f17461ec402ee&#34;&gt;4.热更新&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;c:l(Mod)&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;5-system-limit:9f3b6997f78b7d4fd24f17461ec402ee&#34;&gt;5.system_limit&lt;/h5&gt;

&lt;h5 id=&#34;6-开源库:9f3b6997f78b7d4fd24f17461ec402ee&#34;&gt;6.开源库&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;recon&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>其他文章</title>
      <link>http://wangzun.github.io/posts/hugo-create-blog/</link>
      <pubDate>Thu, 26 May 2016 16:05:06 +0800</pubDate>
      
      <guid>http://wangzun.github.io/posts/hugo-create-blog/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.jianshu.com/users/f3f29a3ca903/latest_articles&#34;&gt;其他文章&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mongodb学习笔记</title>
      <link>http://wangzun.github.io/posts/mongodb-notes/</link>
      <pubDate>Thu, 26 May 2016 16:05:06 +0900</pubDate>
      
      <guid>http://wangzun.github.io/posts/mongodb-notes/</guid>
      <description>

&lt;h5 id=&#34;分片-副本级集群对比:afb814d1e0b452328a71bc59001afa4a&#34;&gt;分片，副本级集群对比&lt;/h5&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;分片&lt;/th&gt;
&lt;th&gt;副本级集群&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;实现意义&lt;/td&gt;
&lt;td&gt;&lt;code&gt;提升并发性能&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;数据沉余，提升度性能&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;架构上&lt;/td&gt;
&lt;td&gt;&lt;code&gt;水平化&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;中心化&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;实现原理&lt;/td&gt;
&lt;td&gt;&lt;code&gt;数据分散&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;数据镜像&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;维护成本&lt;/td&gt;
&lt;td&gt;&lt;code&gt;相对高&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;较容易&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&#34;分片节点:afb814d1e0b452328a71bc59001afa4a&#34;&gt;分片节点&lt;/h5&gt;

&lt;p&gt;Shard节点:
&lt;code&gt;存取数据的节点( 单个mongod)&lt;/code&gt;
Config server:
&lt;code&gt;储存元数据，为mongos服务，路由到Shard&lt;/code&gt;
Mongos
&lt;code&gt;接收请求，进行消息路由&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;成员节点启动参数:afb814d1e0b452328a71bc59001afa4a&#34;&gt;成员节点启动参数&lt;/h5&gt;

&lt;p&gt;Shard:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongod --shardsvr
mongod --shardsvr --rpelSet (副本集)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Config server:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongod --configsvr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mongos&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongos --configdb &amp;lt;configdb server&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分片步骤&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; use admin
&amp;gt; sh.addShard(&amp;quot;ip:port&amp;quot;)
&amp;gt; db.runCommand({enablesharding:&amp;quot;db&amp;quot;})
&amp;gt; db.runCommand({&amp;quot;shardcollection&amp;quot;:&amp;quot;db.collection&amp;quot;,key:{&amp;quot;key&amp;quot;:1}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看shard成员&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; use config
&amp;gt; db.shards.find()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看shard状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; db.printShardingStatus()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;哈希分片&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;db.runCommand({&amp;quot;shardcollection&amp;quot;:&amp;quot;db.collection&amp;quot;,&amp;quot;key&amp;quot;:{key:hashed}})
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;范围分片和哈希分片的对比:afb814d1e0b452328a71bc59001afa4a&#34;&gt;范围分片和哈希分片的对比&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;基于范围的分片方式提供了更高效的范围查询,给定一个片键的范围,分发路由可以很简单地确定哪个数据块存储了请求需要的数据,并将请求转发到相应的分片中.&lt;/p&gt;

&lt;p&gt;不过,基于范围的分片会导致数据在不同分片上的不均衡,有时候,带来的消极作用会大于查询性能的积极作用.比如,如果片键所在的字段是线性增长的,一定时间内的所有请求都会落到某个固定的数据块中,最终导致分布在同一个分片中.在这种情况下,一小部分分片承载了集群大部分的数据,系统并不能很好地进行扩展.&lt;/p&gt;

&lt;p&gt;与此相比,基于哈希的分片方式以范围查询性能的损失为代价,保证了集群中数据的均衡.哈希值的随机性使数据随机分布在每个数据块中,因此也随机分布在不同分片中.但是也正由于随机性,一个范围查询很难确定应该请求哪些分片,通常为了返回需要的结果,需要请求所有分片.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>